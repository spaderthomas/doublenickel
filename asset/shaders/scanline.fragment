#include "common.glsl"

out vec4 color;

in vec4 f_color;
in vec2 f_uv;

uniform sampler2D unprocessed_frame;

// #define hardScan -8.0
// #define shape 2.0
// #define brightBoost 1.0
// #define hardPix -3.0
// #define warpX 0.031
// #define warpY 0.041

// #define input_size render_target
// #define output_size (render_target * 4)

// vec2 Dist(vec2 pos)
// {
//     pos = pos*render_target.xy;
    
//     return -((pos - floor(pos)) - vec2(0.5));
// }

// float Gaus(float pos, float scale)
// {
//     return exp2(scale*pow(abs(pos), shape));
// }

// float Scan(vec2 pos, float off)
// {
//     float dst = Dist(pos).y;

//     return Gaus(dst + off, hardScan);
// }

// vec3 Fetch(vec2 pos,vec2 off){
//   pos = (floor(pos * render_target.xy + off) + vec2(0.5,0.5)) / render_target.xy;
// 	return texture(new_frame, pos.xy).xyz;
// }

// // 3-tap Gaussian filter along horz line.
// vec3 Horz3(vec2 pos, float off)
// {
//     vec3 b    = Fetch(pos, vec2(-1.0, off));
//     vec3 c    = Fetch(pos, vec2( 0.0, off));
//     vec3 d    = Fetch(pos, vec2( 1.0, off));
//     float dst = Dist(pos).x;

//     // Convert distance to weight.
//     float scale = hardPix;
//     float wb = Gaus(dst-1.0,scale);
//     float wc = Gaus(dst+0.0,scale);
//     float wd = Gaus(dst+1.0,scale);

//     // Return filtered sample.
//     return (b*wb+c*wc+d*wd)/(wb+wc+wd);
// }

// // 5-tap Gaussian filter along horz line.
// vec3 Horz5(vec2 pos,float off){
//     vec3 a = Fetch(pos,vec2(-2.0, off));
//     vec3 b = Fetch(pos,vec2(-1.0, off));
//     vec3 c = Fetch(pos,vec2( 0.0, off));
//     vec3 d = Fetch(pos,vec2( 1.0, off));
//     vec3 e = Fetch(pos,vec2( 2.0, off));
    
//     float dst = Dist(pos).x;
//     // Convert distance to weight.
//     float scale = hardPix;
//     float wa = Gaus(dst - 2.0, scale);
//     float wb = Gaus(dst - 1.0, scale);
//     float wc = Gaus(dst + 0.0, scale);
//     float wd = Gaus(dst + 1.0, scale);
//     float we = Gaus(dst + 2.0, scale);
    
//     // Return filtered sample.
//     return (a*wa+b*wb+c*wc+d*wd+e*we)/(wa+wb+wc+wd+we);
// }

// // Allow nearest three lines to effect pixel.
// vec3 Tri(vec2 pos)
// {
//     vec3 a = Horz3(pos,-1.0);
//     vec3 b = Horz5(pos, 0.0);
//     vec3 c = Horz3(pos, 1.0);
    
//     float wa = Scan(pos,-1.0); 
//     float wb = Scan(pos, 0.0);
//     float wc = Scan(pos, 1.0);
    
//     return a*wa + b*wb + c*wc;
// }

// vec2 Warp(vec2 pos)
// {
//     pos  = pos*2.0-1.0;    
//     pos *= vec2(1.0 + (pos.y*pos.y)*warpX, 1.0 + (pos.x*pos.x)*warpY);
    
//     return pos*0.5 + 0.5;
// }
// vec4 lotte() {
// 	vec2 pos = Warp(f_uv * (render_target.xy / input_size.xy)) * (input_size.xy / render_target.xy);
// 	return vec4(Tri(f_uv), 1.0); 

// }

void main() {
	vec2 uv = f_uv + camera / render_target;
	vec4 sample_color = texture(unprocessed_frame, f_uv);
	vec4 sample_color_hsv = rgb_to_hsv_4(sample_color);

	const float scanline_height_px = 7;
	const float scanline_height = scanline_height_px / render_target.y;

	const float num_scanlines = render_target.y / scanline_height_px;
	float scan_position = fract(uv.y * num_scanlines);
	float scanline_power = triangle_wave(scan_position - .5);
	scanline_power = map_range(scanline_power, 0.5, 1.0, 0.0, 1.0); 
	scanline_power = 1.0 - scanline_power;
	scanline_power = ease_in_out_cubic(scanline_power);

	vec4 scanline_color = rgb_to_hsv_4(sample_color);

	float hue_min = 210.0 / 360.0;
	float white_cutoff = 0.1;
	if (HSV_SATURATION(scanline_color) < white_cutoff) {
		HSV_HUE(scanline_color) = hue_min;
	}

	// The actual color of the scanline is blue; move colors towards blue, with colors farther from blue moving more
	float scanline_hue = 240.0 / 360.0;
	float hue_power = HSV_HUE(scanline_color) - scanline_hue;
	hue_power = map_range(hue_power, -1.0, 1.0, 0.0, 1.0);
	hue_power = ease_out_cubic(hue_power);
	
	// Pretty much just double the saturation; for white, we need at least a little to work with
	float saturation_target = clamp(HSV_SATURATION(scanline_color) * 1.0, 0.2, 1.0);

	// Dark things should become a good bit darker, while light things should become just a bit darker
	float value_target = clamp(ease_in_quadratic(HSV_VALUE(scanline_color)), 0.0, 0.9);

	// HSV_HUE(scanline_color) = mix(HSV_HUE(scanline_color), scanline_hue, 1.0 - hue_power);
	HSV_SATURATION(scanline_color) = mix(HSV_SATURATION(scanline_color), saturation_target, scanline_power);
	HSV_VALUE(scanline_color) = mix(HSV_VALUE(scanline_color), value_target, scanline_power);
	scanline_color = hsv_to_rgb_4(scanline_color);

	color = scanline_color;
	return;
}
