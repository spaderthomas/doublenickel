#include "common.glsl"

out vec4 color;

in vec4 f_color;
in vec2 f_uv;

uniform sampler2D unprocessed_frame;
uniform sampler2D bloom_map;

// #define hardScan -8.0
// #define shape 2.0
// #define brightBoost 1.0
// #define hardPix -3.0
// #define warpX 0.031
// #define warpY 0.041

// #define input_size output_resolution
// #define output_size (output_resolution * 4)

// vec2 Dist(vec2 pos)
// {
//     pos = pos*output_resolution.xy;
    
//     return -((pos - floor(pos)) - vec2(0.5));
// }

// float Gaus(float pos, float scale)
// {
//     return exp2(scale*pow(abs(pos), shape));
// }

// float Scan(vec2 pos, float off)
// {
//     float dst = Dist(pos).y;

//     return Gaus(dst + off, hardScan);
// }

// vec3 Fetch(vec2 pos,vec2 off){
//   pos = (floor(pos * output_resolution.xy + off) + vec2(0.5,0.5)) / output_resolution.xy;
// 	return texture(new_frame, pos.xy).xyz;
// }

// // 3-tap Gaussian filter along horz line.
// vec3 Horz3(vec2 pos, float off)
// {
//     vec3 b    = Fetch(pos, vec2(-1.0, off));
//     vec3 c    = Fetch(pos, vec2( 0.0, off));
//     vec3 d    = Fetch(pos, vec2( 1.0, off));
//     float dst = Dist(pos).x;

//     // Convert distance to weight.
//     float scale = hardPix;
//     float wb = Gaus(dst-1.0,scale);
//     float wc = Gaus(dst+0.0,scale);
//     float wd = Gaus(dst+1.0,scale);

//     // Return filtered sample.
//     return (b*wb+c*wc+d*wd)/(wb+wc+wd);
// }

// // 5-tap Gaussian filter along horz line.
// vec3 Horz5(vec2 pos,float off){
//     vec3 a = Fetch(pos,vec2(-2.0, off));
//     vec3 b = Fetch(pos,vec2(-1.0, off));
//     vec3 c = Fetch(pos,vec2( 0.0, off));
//     vec3 d = Fetch(pos,vec2( 1.0, off));
//     vec3 e = Fetch(pos,vec2( 2.0, off));
    
//     float dst = Dist(pos).x;
//     // Convert distance to weight.
//     float scale = hardPix;
//     float wa = Gaus(dst - 2.0, scale);
//     float wb = Gaus(dst - 1.0, scale);
//     float wc = Gaus(dst + 0.0, scale);
//     float wd = Gaus(dst + 1.0, scale);
//     float we = Gaus(dst + 2.0, scale);
    
//     // Return filtered sample.
//     return (a*wa+b*wb+c*wc+d*wd+e*we)/(wa+wb+wc+wd+we);
// }

// // Allow nearest three lines to effect pixel.
// vec3 Tri(vec2 pos)
// {
//     vec3 a = Horz3(pos,-1.0);
//     vec3 b = Horz5(pos, 0.0);
//     vec3 c = Horz3(pos, 1.0);
    
//     float wa = Scan(pos,-1.0); 
//     float wb = Scan(pos, 0.0);
//     float wc = Scan(pos, 1.0);
    
//     return a*wa + b*wb + c*wc;
// }

// vec2 Warp(vec2 pos)
// {
//     pos  = pos*2.0-1.0;    
//     pos *= vec2(1.0 + (pos.y*pos.y)*warpX, 1.0 + (pos.x*pos.x)*warpY);
    
//     return pos*0.5 + 0.5;
// }
// vec4 lotte() {
// 	vec2 pos = Warp(f_uv * (output_resolution.xy / input_size.xy)) * (input_size.xy / output_resolution.xy);
// 	return vec4(Tri(f_uv), 1.0); 

// }

void main() {
	vec2 uv = f_uv + camera / output_resolution;
	vec4 sample_color = texture(unprocessed_frame, f_uv);
	vec4 sample_color_hsv = rgb_to_hsv_4(sample_color);

	const float scanline_height_px = 7;
	const float scanline_height = scanline_height_px / output_resolution.y;

	const float num_scanlines = output_resolution.y / scanline_height_px;
	float scan_position = fract(uv.y * num_scanlines);
	float scanline_power = triangle_wave(scan_position - .5);
	scanline_power = map_range(scanline_power, 0.5, 1.0, 0.0, 1.0); 
	scanline_power = 1.0 - scanline_power;
	scanline_power = ease_in_out_cubic(scanline_power); 
	// float scanline_power = scan_position;
	// scanline_power = map_range(scanline_power, 0.5, 1.0, 0.0, 1.0); 
	// color = make_red(scanline_power); return;

	vec4 bloom = texture(bloom_map, f_uv);
	// vec4 scanline_light = color_255(191.0, 217.0, 237.0, 255.0);
	vec4 scanline_light = color_255(100.0, 130.0, 200.0, 255.0) * 1.15;
	vec4 scanline_dark = color_255(12.0, 8.0, 100.0, 255.0);
	vec4 scanline_color = mix(scanline_dark, scanline_light, bloom.r);
	// color = mix(sample_color, scanline_light, scanline_power * bloom.r);

	// float strength_dark = double_pass(bloom.r, 0.4, 1.0);
	// float strength_dark = high_pass(bloom.r, 0.0);

	color = sample_color;

	float strength_dark = (bloom.r - bloom.b) * scanline_power;
	color = mix(color, scanline_dark, strength_dark);

	float strength_light = bloom.b * (1.0 - scanline_power);
	color = mix(color, scanline_light, strength_light);


	// color = mix(sample_color, scanline_dark, strength);
	// color = mix(color, scanline_light, strength);
	// color = mix(sample_color, blue, bloom.r);
	// color = sample_color;
	// color = make_red(bloom.r);
	// color = make_red(bloom.r + bloom.g / 8);
	// color = scanline_color;
	// color = make_red(strength_dark);
	// color = make_red(strength_light);
	// color = mix(sample_color, make_red(strength_dark), 0.5);
	return;
}
