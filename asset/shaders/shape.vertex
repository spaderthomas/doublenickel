#include "common.glsl"
#include "sdf.glsl"

layout (location = 0) in vec2 vertex_position;
layout (location = 1) in vec2 vertex_uv;
layout (location = 2) in uint index;


out vec2 f_uv;
out uint f_index;

uniform mat4 projection;
uniform mat4 view;


void main() {
	SdfIndex sdf_index = decode_sdf_index(index);

	SdfHeader header = pull_header(sdf_index.buffer_index);
	if (sdf_index.shape == SDF_CIRCLE) {
		SdfCircle circle = pull_circle(sdf_index.buffer_index);

		mat3 transform_matrix = transformation_matrix(header.position, header.rotation, vec2(circle.radius * 2));
		vec3 transformed_position = transform_matrix * vec3(vertex_position, 1.0);
		gl_Position = projection * view * vec4(transformed_position.xy, 1.0, 1.0);
	}
	else if (sdf_index.shape == SDF_RING) {
		SdfRing ring = pull_ring(sdf_index.buffer_index);

		mat3 transform_matrix = transformation_matrix(header.position, header.rotation, vec2(ring.outer_radius * 2));
		vec3 transformed_position = transform_matrix * vec3(vertex_position, 1.0);
		gl_Position = projection * view * vec4(transformed_position.xy, 1.0, 1.0);
	}
	else if (sdf_index.shape == SDF_ORIENTED_BOX) {
		SdfOrientedBox box = pull_oriented_box(sdf_index.buffer_index);

		mat3 transform_matrix = transformation_matrix(header.position, header.rotation, box.size);
		vec3 transformed_position = transform_matrix * vec3(vertex_position, 1.0);
		gl_Position = projection * view * vec4(transformed_position.xy, 1.0, 1.0);
	}

	else {
		vec2 transformed_position = vertex_position * 5;
		gl_Position = projection * view * vec4(transformed_position, 1.0, 1.0);
	}



	// f_color = color;
	f_uv = vertex_uv;
	f_index = index;
}
